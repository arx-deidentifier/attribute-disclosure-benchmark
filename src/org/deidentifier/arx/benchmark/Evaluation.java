/*
 * Attribute disclosure benchmark
 * Benchmark of methods for protecting data from attribute disclosure
 * 
 * Copyright (C) 2019 Helmut Spengler, Fabian Prasser
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

package org.deidentifier.arx.benchmark;

import java.io.File;
import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import de.linearbits.objectselector.Selector;
import de.linearbits.subframe.analyzer.Analyzer;
import de.linearbits.subframe.graph.Labels;
import de.linearbits.subframe.graph.Plot;
import de.linearbits.subframe.graph.PlotLinesClustered;
import de.linearbits.subframe.graph.Point3D;
import de.linearbits.subframe.graph.Series3D;
import de.linearbits.subframe.io.CSVFile;
import de.linearbits.subframe.io.CSVLine;
import de.linearbits.subframe.render.GnuPlotParams;
import de.linearbits.subframe.render.GnuPlotParams.KeyPos;
import de.linearbits.subframe.render.LaTeX;
import de.linearbits.subframe.render.PlotGroup;

/**
 * Plot RU-Curves
 * 
 * @author Helmut Spengler
 *
 */
public class Evaluation {

    /**
     * Identifies the record with the highest utility and returns
     * respective x and y values
     * @author Helmut Spengler
     *
     */
    public static class BufferedAnalyzer {        

        private final List<Double> risks = new ArrayList<>();
        private final List<Double> utilities = new ArrayList<>();

        /**
         * Constructor
         */
        protected BufferedAnalyzer() {
        }

        /**
         * Adds a new pair for analysis
         * @param risk
         * @param utility
         */
        public void add (double risk, double utility) {
            risks.add(risk);
            utilities.add(utility);
        }

        /**
         * @return the pair {risk,utility} with the highest utility
         */
        public String[] getOptimum() {
            int optIndex = Integer.MIN_VALUE;
            double optVal = -Double.MAX_VALUE;

            for (int i = 0; i < utilities.size(); i++) {
                double utility = utilities.get(i);

                if (utility > optVal) {
                    optIndex = i;
                    optVal = utility;
                }
            }

            return new String[] { String.valueOf(risks.get(optIndex)), String.valueOf(utilities.get(optIndex)) };
        }
    }
    
    
    
    /**
     * Main entry point for evaluating experimental results. This method requires the file 
     * results.csv as generated by Experiment.main()
     * @throws IOException
     * @throws ParseException
     */
    public static void main(String[] args) throws IOException, ParseException {
        
        // Check state
        File file = new File(BenchmarkSetup.RESULTS_FILENAME);
        if (!file.exists()) {
            throw new IllegalStateException("File " + BenchmarkSetup.RESULTS_FILENAME + " could no be found. Please execute Experiment.main() first.");
        }  

        // Init
        CSVFile csvFile = new CSVFile(file);
        List<PlotGroup> groups = new ArrayList<PlotGroup>();
        List<Plot<?>> plots = new ArrayList<Plot<?>>();
        
        // Configure GnuPlot
        GnuPlotParams params = new GnuPlotParams();
        params.keypos = KeyPos.NONE;
        params.size = 0.4d;
        params.minX = 0d;
        params.minY = 0d;
        params.maxX = 1d;
        params.maxY = 1d;
        params.lineWidth=1.5d;
        params.font = "Times,10";
        params.grid=false;
        params.lineType = GnuPlotParams.LineType.STEPS;
        
        // Create plots for datasets
        addPlotForDataset("Census", "Marital status", plots, csvFile);
        addPlotForDataset("Health interviews", "MARSTAT", plots, csvFile);
        addPlotForDataset("Census", "Education", plots, csvFile);
        addPlotForDataset("Health interviews", "EDUC", plots, csvFile);
        
        // Plot
        groups.add(new PlotGroup("R-U curves for privacy models protecting against attribute disclosure", plots, params, .20d));
        LaTeX.plot(groups, "results/Evaluation", true);
    }

    /**
     * Returns a series for a dataset containing the curves for the privacy models
     * @param dataset
     * @param plots
     * @param file
     * @param sensitive attribute
     * @return
     * @throws ParseException
     */
    private static void addPlotForDataset(String dataset, String sa, List<Plot<?>> plots, CSVFile file) throws ParseException {
        
        // Init series
        Series3D series = new Series3D();     
        
        // Determine values for actual privacy models
        series.append(getSeriesForModel(file, dataset, sa, "DISTINCT_L_DIVERSITY"));
        series.append(getSeriesForModel(file, dataset, sa, "T_CLOSENESS"));
        series.append(getSeriesForModel(file, dataset, sa, "ENHANCED_B_LIKENESS"));

        // Draw linear relationship
        series.getData().add(new Point3D(String.valueOf(1.0), "linear rel.", String.valueOf(1.0)));  
        series.getData().add(new Point3D(String.valueOf(0.0), "linear rel.", String.valueOf(0.0)));

        // It is ok, if multiple y-values appear for the same x-value
        series.setStrict(false);
        
        plots.add(new PlotLinesClustered(dataset + " / " + sa, new Labels("Risk", "Utility"), series));
    }


    /**
     * Extract baseline values {fpRisk, fpUtility, npRisk, npUtility}
     * @param file
     * @param dataset
     * @param sensitive attribute
     * @return {fpRisk, fpUtility, npRisk, npUtility}
     * @throws ParseException 
     */
    private static double[] extractBaselineValues(CSVFile file, String dataset, String sa) throws ParseException {
        
        // Extract raw values
        Series3D kAnonSeries = getSeriesForModel(file, dataset, sa, "K_ANONYMITY");   
        
        // Calculate actual values
        double npRisk = Double.valueOf(kAnonSeries.getData().get(0).x);
        double npUtility = Double.valueOf(kAnonSeries.getData().get(0).z);        
        double fpRisk = 0d;
        double fpUtility = npUtility - 0.25;
        
        return new double[] { fpRisk, fpUtility, npRisk, npUtility };
    }

    /**
     * Returns a series for a certain privacy model
     * @param file
     * @param dataset
     * @param sensitive attribute
     * @param privacyMeasure
     * @return
     * @throws ParseException
     */
    private static Series3D getSeriesForModel(CSVFile file, String dataset, String sa, String privacyMeasure) throws ParseException {  
        
        // Select raw data
        Selector<String[]> selector = file.getSelectorBuilder()
                .field("dataset").equals(dataset)
                .and()
                .field("sensitive").equals(sa)
                .and()
                .field("model").equals(privacyMeasure)
                .build();

        // Extract coordinates for plot
        Series3D series = createSeries3D(
                                privacyMeasure,
                                file, 
                                selector,
                                dataset, sa);
        
        if (!"K_ANONYMITY".equals(privacyMeasure)) {
            return zoom(series, privacyMeasure, extractBaselineValues(file, dataset, sa));
        } else {
            return series;
        }
    }

    /**
     * Creates a series by selecting rows with a constant privacyMeasure,
     * grouping by threshold using analyzer and returning corresponding acc as x,
     * static privacyMeasure, and information content as z coordinate
     * @param privacyMeasure
     * @param file
     * @param selector
     * @param dataset
     * @param sa
     * @return
     */
    private static Series3D createSeries3D(String privacyMeasure,
                                           CSVFile file,
                                           Selector<String[]> selector,
                                           String dataset, String sa) {

        // Init
        String pmMapped = renamePm(privacyMeasure);
        Map<String, BufferedAnalyzer> analyzers = new LinkedHashMap<>();

        // Load data into analysis data structure
        Iterator<CSVLine> iter = file.iterator();
        while (iter.hasNext()) {
            CSVLine csvline = iter.next();
            String[] line = csvline.getData();
            if (selector.isSelected(line)) {
   
                // read  data
                String threshold = csvline.get("", "threshold");                
                double risk = Double.valueOf(csvline.get("accuracy_lr_anon", Analyzer.VALUE));
                
                // calculate loss
                double loss = Double.valueOf(csvline.get("quality_loss", Analyzer.VALUE));
                double utility = (0.75 * loss) + (0.25 * 1d);
                
                // if necessary, generate new group, else put data into existing group
                if (!analyzers.containsKey(threshold)) {
                    analyzers.put(threshold, new BufferedAnalyzer());
                }
                analyzers.get(threshold).add(risk, utility);
            }
        }

        // analyze and generate result
        Series3D series = new Series3D();
        for (Entry<String, BufferedAnalyzer> entry : analyzers.entrySet()) {
            series.getData().add(new Point3D(entry.getValue().getOptimum()[0], pmMapped, entry.getValue().getOptimum()[1]));
        }

        return series;
    }

    /**
     * Transform coordinates relative to baseline coordinates "full protection" and "no protection"
     * @param series
     * @param privacyMeasure
     * @param baselineValues { fpRisk, fpUtility, npRisk, npUtility }
     * @return
     */
    private static Series3D zoom(Series3D series, String privacyMeasure, double[] baselineValues) {

        // Assemble result
        Series3D result = new Series3D();    
        result.getData().add(new Point3D("1.0", renamePm(privacyMeasure), "1.0"));
        for (Point3D point3D : series.getData()) {

            double xMin = baselineValues[0]; double yMin = baselineValues[1];
            double xMax = baselineValues[2]; double yMax = baselineValues[3];

            double x = (Double.valueOf(point3D.x) - xMin) / (xMax - xMin);
            double y = (Double.valueOf(point3D.z) - yMin) / (yMax - yMin);

            result.getData().add(new Point3D(String.valueOf(x), renamePm(privacyMeasure), String.valueOf(y)));
        }
        result.getData().add(new Point3D("0.0", renamePm(privacyMeasure), "0.0"));
        
        // Sort by x-coordinate
        result.sort(new Comparator<Point3D>() {
            @Override
            public int compare(Point3D o1, Point3D o2) {
                return Double.compare(Double.valueOf(o1.x), Double.valueOf(o2.x));
            }
        });
        
        return result;
    }


    /**
     * Map PM strings to be displayed in plot
     * @param privacyMeasure
     * @return
     */
    private static String renamePm(String privacyMeasure) {
        if ("DISTINCT_L_DIVERSITY".equals(privacyMeasure)) {
            return "l-diversity";
        } else if ("RECURSIVE_CL_DIVERSITY".equals(privacyMeasure)) {
            return "RL";
        } else if ("ENTROPY_L_DIVERSITY".equals(privacyMeasure)) {
            return "EL";
        } else if ("T_CLOSENESS".equals(privacyMeasure)) {
            return "t-closeness";
        } else if ("D_DISCLOSURE_PRIVACY".equals(privacyMeasure)) {
            return "DDP";
        } else if ("BASIC_B_LIKENESS".equals(privacyMeasure)) {
            return "BBL";
        } else if ("ENHANCED_B_LIKENESS".equals(privacyMeasure)) {
            return "{/Symbol b}-likeness";
        } else if ("K_ANONYMITY".equals(privacyMeasure)) {
            return "K_ANONYMITY";
        } else {
            throw new IllegalArgumentException("Unsupported privacy measure: " + privacyMeasure);
        }
    }
}
